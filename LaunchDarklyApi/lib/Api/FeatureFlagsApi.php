<?php
/**
 * FeatureFlagsApi
 * PHP version 5
 *
 * @category Class
 * @package  LaunchDarklyApi
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * LaunchDarkly REST API
 *
 * Build custom integrations with the LaunchDarkly REST API
 *
 * OpenAPI spec version: 5.3.0
 * Contact: support@launchdarkly.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.17
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace LaunchDarklyApi\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use LaunchDarklyApi\ApiException;
use LaunchDarklyApi\Configuration;
use LaunchDarklyApi\HeaderSelector;
use LaunchDarklyApi\ObjectSerializer;

/**
 * FeatureFlagsApi Class Doc Comment
 *
 * @category Class
 * @package  LaunchDarklyApi
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class FeatureFlagsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation copyFeatureFlag
     *
     * Copies the feature flag configuration from one environment to the same feature flag in another environment.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\FeatureFlagCopyBody $feature_flag_copy_body Copy feature flag configurations between environments. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\FeatureFlag
     */
    public function copyFeatureFlag($project_key, $feature_flag_key, $feature_flag_copy_body)
    {
        list($response) = $this->copyFeatureFlagWithHttpInfo($project_key, $feature_flag_key, $feature_flag_copy_body);
        return $response;
    }

    /**
     * Operation copyFeatureFlagWithHttpInfo
     *
     * Copies the feature flag configuration from one environment to the same feature flag in another environment.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\FeatureFlagCopyBody $feature_flag_copy_body Copy feature flag configurations between environments. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\FeatureFlag, HTTP status code, HTTP response headers (array of strings)
     */
    public function copyFeatureFlagWithHttpInfo($project_key, $feature_flag_key, $feature_flag_copy_body)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlag';
        $request = $this->copyFeatureFlagRequest($project_key, $feature_flag_key, $feature_flag_copy_body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\FeatureFlag',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation copyFeatureFlagAsync
     *
     * Copies the feature flag configuration from one environment to the same feature flag in another environment.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\FeatureFlagCopyBody $feature_flag_copy_body Copy feature flag configurations between environments. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyFeatureFlagAsync($project_key, $feature_flag_key, $feature_flag_copy_body)
    {
        return $this->copyFeatureFlagAsyncWithHttpInfo($project_key, $feature_flag_key, $feature_flag_copy_body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation copyFeatureFlagAsyncWithHttpInfo
     *
     * Copies the feature flag configuration from one environment to the same feature flag in another environment.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\FeatureFlagCopyBody $feature_flag_copy_body Copy feature flag configurations between environments. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyFeatureFlagAsyncWithHttpInfo($project_key, $feature_flag_key, $feature_flag_copy_body)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlag';
        $request = $this->copyFeatureFlagRequest($project_key, $feature_flag_key, $feature_flag_copy_body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'copyFeatureFlag'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\FeatureFlagCopyBody $feature_flag_copy_body Copy feature flag configurations between environments. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function copyFeatureFlagRequest($project_key, $feature_flag_key, $feature_flag_copy_body)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling copyFeatureFlag'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling copyFeatureFlag'
            );
        }
        // verify the required parameter 'feature_flag_copy_body' is set
        if ($feature_flag_copy_body === null || (is_array($feature_flag_copy_body) && count($feature_flag_copy_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_copy_body when calling copyFeatureFlag'
            );
        }

        $resourcePath = '/flags/{projectKey}/{featureFlagKey}/copy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($feature_flag_copy_body)) {
            $_tempBody = $feature_flag_copy_body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteApprovalRequest
     *
     * Delete an approval request for a feature flag config
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $approval_request_id The approval request ID (required)
     * @param  \LaunchDarklyApi\Model\ApprovalRequestConfigBody $approval_request_config_body Create a new approval request (optional)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteApprovalRequest($project_key, $environment_key, $feature_flag_key, $approval_request_id, $approval_request_config_body = null)
    {
        $this->deleteApprovalRequestWithHttpInfo($project_key, $environment_key, $feature_flag_key, $approval_request_id, $approval_request_config_body);
    }

    /**
     * Operation deleteApprovalRequestWithHttpInfo
     *
     * Delete an approval request for a feature flag config
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $approval_request_id The approval request ID (required)
     * @param  \LaunchDarklyApi\Model\ApprovalRequestConfigBody $approval_request_config_body Create a new approval request (optional)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteApprovalRequestWithHttpInfo($project_key, $environment_key, $feature_flag_key, $approval_request_id, $approval_request_config_body = null)
    {
        $returnType = '';
        $request = $this->deleteApprovalRequestRequest($project_key, $environment_key, $feature_flag_key, $approval_request_id, $approval_request_config_body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteApprovalRequestAsync
     *
     * Delete an approval request for a feature flag config
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $approval_request_id The approval request ID (required)
     * @param  \LaunchDarklyApi\Model\ApprovalRequestConfigBody $approval_request_config_body Create a new approval request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteApprovalRequestAsync($project_key, $environment_key, $feature_flag_key, $approval_request_id, $approval_request_config_body = null)
    {
        return $this->deleteApprovalRequestAsyncWithHttpInfo($project_key, $environment_key, $feature_flag_key, $approval_request_id, $approval_request_config_body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteApprovalRequestAsyncWithHttpInfo
     *
     * Delete an approval request for a feature flag config
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $approval_request_id The approval request ID (required)
     * @param  \LaunchDarklyApi\Model\ApprovalRequestConfigBody $approval_request_config_body Create a new approval request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteApprovalRequestAsyncWithHttpInfo($project_key, $environment_key, $feature_flag_key, $approval_request_id, $approval_request_config_body = null)
    {
        $returnType = '';
        $request = $this->deleteApprovalRequestRequest($project_key, $environment_key, $feature_flag_key, $approval_request_id, $approval_request_config_body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteApprovalRequest'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $approval_request_id The approval request ID (required)
     * @param  \LaunchDarklyApi\Model\ApprovalRequestConfigBody $approval_request_config_body Create a new approval request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteApprovalRequestRequest($project_key, $environment_key, $feature_flag_key, $approval_request_id, $approval_request_config_body = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling deleteApprovalRequest'
            );
        }
        // verify the required parameter 'environment_key' is set
        if ($environment_key === null || (is_array($environment_key) && count($environment_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_key when calling deleteApprovalRequest'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling deleteApprovalRequest'
            );
        }
        // verify the required parameter 'approval_request_id' is set
        if ($approval_request_id === null || (is_array($approval_request_id) && count($approval_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $approval_request_id when calling deleteApprovalRequest'
            );
        }

        $resourcePath = '/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{approvalRequestId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($environment_key !== null) {
            $resourcePath = str_replace(
                '{' . 'environmentKey' . '}',
                ObjectSerializer::toPathValue($environment_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }
        // path params
        if ($approval_request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'approvalRequestId' . '}',
                ObjectSerializer::toPathValue($approval_request_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($approval_request_config_body)) {
            $_tempBody = $approval_request_config_body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFeatureFlag
     *
     * Delete a feature flag in all environments. Be careful-- only delete feature flags that are no longer being used by your application.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteFeatureFlag($project_key, $feature_flag_key)
    {
        $this->deleteFeatureFlagWithHttpInfo($project_key, $feature_flag_key);
    }

    /**
     * Operation deleteFeatureFlagWithHttpInfo
     *
     * Delete a feature flag in all environments. Be careful-- only delete feature flags that are no longer being used by your application.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFeatureFlagWithHttpInfo($project_key, $feature_flag_key)
    {
        $returnType = '';
        $request = $this->deleteFeatureFlagRequest($project_key, $feature_flag_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFeatureFlagAsync
     *
     * Delete a feature flag in all environments. Be careful-- only delete feature flags that are no longer being used by your application.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFeatureFlagAsync($project_key, $feature_flag_key)
    {
        return $this->deleteFeatureFlagAsyncWithHttpInfo($project_key, $feature_flag_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFeatureFlagAsyncWithHttpInfo
     *
     * Delete a feature flag in all environments. Be careful-- only delete feature flags that are no longer being used by your application.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFeatureFlagAsyncWithHttpInfo($project_key, $feature_flag_key)
    {
        $returnType = '';
        $request = $this->deleteFeatureFlagRequest($project_key, $feature_flag_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFeatureFlag'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteFeatureFlagRequest($project_key, $feature_flag_key)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling deleteFeatureFlag'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling deleteFeatureFlag'
            );
        }

        $resourcePath = '/flags/{projectKey}/{featureFlagKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFlagConfigScheduledChanges
     *
     * Delete a scheduled change on a feature flag in an environment.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $scheduled_change_id The id of the scheduled change (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteFlagConfigScheduledChanges($project_key, $feature_flag_key, $environment_key, $scheduled_change_id)
    {
        $this->deleteFlagConfigScheduledChangesWithHttpInfo($project_key, $feature_flag_key, $environment_key, $scheduled_change_id);
    }

    /**
     * Operation deleteFlagConfigScheduledChangesWithHttpInfo
     *
     * Delete a scheduled change on a feature flag in an environment.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $scheduled_change_id The id of the scheduled change (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFlagConfigScheduledChangesWithHttpInfo($project_key, $feature_flag_key, $environment_key, $scheduled_change_id)
    {
        $returnType = '';
        $request = $this->deleteFlagConfigScheduledChangesRequest($project_key, $feature_flag_key, $environment_key, $scheduled_change_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFlagConfigScheduledChangesAsync
     *
     * Delete a scheduled change on a feature flag in an environment.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $scheduled_change_id The id of the scheduled change (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFlagConfigScheduledChangesAsync($project_key, $feature_flag_key, $environment_key, $scheduled_change_id)
    {
        return $this->deleteFlagConfigScheduledChangesAsyncWithHttpInfo($project_key, $feature_flag_key, $environment_key, $scheduled_change_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFlagConfigScheduledChangesAsyncWithHttpInfo
     *
     * Delete a scheduled change on a feature flag in an environment.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $scheduled_change_id The id of the scheduled change (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFlagConfigScheduledChangesAsyncWithHttpInfo($project_key, $feature_flag_key, $environment_key, $scheduled_change_id)
    {
        $returnType = '';
        $request = $this->deleteFlagConfigScheduledChangesRequest($project_key, $feature_flag_key, $environment_key, $scheduled_change_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFlagConfigScheduledChanges'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $scheduled_change_id The id of the scheduled change (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteFlagConfigScheduledChangesRequest($project_key, $feature_flag_key, $environment_key, $scheduled_change_id)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling deleteFlagConfigScheduledChanges'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling deleteFlagConfigScheduledChanges'
            );
        }
        // verify the required parameter 'environment_key' is set
        if ($environment_key === null || (is_array($environment_key) && count($environment_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_key when calling deleteFlagConfigScheduledChanges'
            );
        }
        // verify the required parameter 'scheduled_change_id' is set
        if ($scheduled_change_id === null || (is_array($scheduled_change_id) && count($scheduled_change_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $scheduled_change_id when calling deleteFlagConfigScheduledChanges'
            );
        }

        $resourcePath = '/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes/{scheduledChangeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }
        // path params
        if ($environment_key !== null) {
            $resourcePath = str_replace(
                '{' . 'environmentKey' . '}',
                ObjectSerializer::toPathValue($environment_key),
                $resourcePath
            );
        }
        // path params
        if ($scheduled_change_id !== null) {
            $resourcePath = str_replace(
                '{' . 'scheduledChangeId' . '}',
                ObjectSerializer::toPathValue($scheduled_change_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation flagsProjectKeyEnvironmentKeyFeatureFlagKeyDependentFlagsGet
     *
     * Get dependent flags for the flag in the environment specified in path parameters
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\DependentFlagsByEnvironment
     */
    public function flagsProjectKeyEnvironmentKeyFeatureFlagKeyDependentFlagsGet($project_key, $environment_key, $feature_flag_key)
    {
        list($response) = $this->flagsProjectKeyEnvironmentKeyFeatureFlagKeyDependentFlagsGetWithHttpInfo($project_key, $environment_key, $feature_flag_key);
        return $response;
    }

    /**
     * Operation flagsProjectKeyEnvironmentKeyFeatureFlagKeyDependentFlagsGetWithHttpInfo
     *
     * Get dependent flags for the flag in the environment specified in path parameters
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\DependentFlagsByEnvironment, HTTP status code, HTTP response headers (array of strings)
     */
    public function flagsProjectKeyEnvironmentKeyFeatureFlagKeyDependentFlagsGetWithHttpInfo($project_key, $environment_key, $feature_flag_key)
    {
        $returnType = '\LaunchDarklyApi\Model\DependentFlagsByEnvironment';
        $request = $this->flagsProjectKeyEnvironmentKeyFeatureFlagKeyDependentFlagsGetRequest($project_key, $environment_key, $feature_flag_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\DependentFlagsByEnvironment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\UsageError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation flagsProjectKeyEnvironmentKeyFeatureFlagKeyDependentFlagsGetAsync
     *
     * Get dependent flags for the flag in the environment specified in path parameters
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function flagsProjectKeyEnvironmentKeyFeatureFlagKeyDependentFlagsGetAsync($project_key, $environment_key, $feature_flag_key)
    {
        return $this->flagsProjectKeyEnvironmentKeyFeatureFlagKeyDependentFlagsGetAsyncWithHttpInfo($project_key, $environment_key, $feature_flag_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation flagsProjectKeyEnvironmentKeyFeatureFlagKeyDependentFlagsGetAsyncWithHttpInfo
     *
     * Get dependent flags for the flag in the environment specified in path parameters
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function flagsProjectKeyEnvironmentKeyFeatureFlagKeyDependentFlagsGetAsyncWithHttpInfo($project_key, $environment_key, $feature_flag_key)
    {
        $returnType = '\LaunchDarklyApi\Model\DependentFlagsByEnvironment';
        $request = $this->flagsProjectKeyEnvironmentKeyFeatureFlagKeyDependentFlagsGetRequest($project_key, $environment_key, $feature_flag_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'flagsProjectKeyEnvironmentKeyFeatureFlagKeyDependentFlagsGet'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function flagsProjectKeyEnvironmentKeyFeatureFlagKeyDependentFlagsGetRequest($project_key, $environment_key, $feature_flag_key)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling flagsProjectKeyEnvironmentKeyFeatureFlagKeyDependentFlagsGet'
            );
        }
        // verify the required parameter 'environment_key' is set
        if ($environment_key === null || (is_array($environment_key) && count($environment_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_key when calling flagsProjectKeyEnvironmentKeyFeatureFlagKeyDependentFlagsGet'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling flagsProjectKeyEnvironmentKeyFeatureFlagKeyDependentFlagsGet'
            );
        }

        $resourcePath = '/flags/{projectKey}/{environmentKey}/{featureFlagKey}/dependent-flags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($environment_key !== null) {
            $resourcePath = str_replace(
                '{' . 'environmentKey' . '}',
                ObjectSerializer::toPathValue($environment_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation flagsProjectKeyFeatureFlagKeyDependentFlagsGet
     *
     * Get dependent flags across all environments for the flag specified in the path parameters
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\MultiEnvironmentDependentFlags
     */
    public function flagsProjectKeyFeatureFlagKeyDependentFlagsGet($project_key, $feature_flag_key)
    {
        list($response) = $this->flagsProjectKeyFeatureFlagKeyDependentFlagsGetWithHttpInfo($project_key, $feature_flag_key);
        return $response;
    }

    /**
     * Operation flagsProjectKeyFeatureFlagKeyDependentFlagsGetWithHttpInfo
     *
     * Get dependent flags across all environments for the flag specified in the path parameters
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\MultiEnvironmentDependentFlags, HTTP status code, HTTP response headers (array of strings)
     */
    public function flagsProjectKeyFeatureFlagKeyDependentFlagsGetWithHttpInfo($project_key, $feature_flag_key)
    {
        $returnType = '\LaunchDarklyApi\Model\MultiEnvironmentDependentFlags';
        $request = $this->flagsProjectKeyFeatureFlagKeyDependentFlagsGetRequest($project_key, $feature_flag_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\MultiEnvironmentDependentFlags',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\UsageError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation flagsProjectKeyFeatureFlagKeyDependentFlagsGetAsync
     *
     * Get dependent flags across all environments for the flag specified in the path parameters
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function flagsProjectKeyFeatureFlagKeyDependentFlagsGetAsync($project_key, $feature_flag_key)
    {
        return $this->flagsProjectKeyFeatureFlagKeyDependentFlagsGetAsyncWithHttpInfo($project_key, $feature_flag_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation flagsProjectKeyFeatureFlagKeyDependentFlagsGetAsyncWithHttpInfo
     *
     * Get dependent flags across all environments for the flag specified in the path parameters
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function flagsProjectKeyFeatureFlagKeyDependentFlagsGetAsyncWithHttpInfo($project_key, $feature_flag_key)
    {
        $returnType = '\LaunchDarklyApi\Model\MultiEnvironmentDependentFlags';
        $request = $this->flagsProjectKeyFeatureFlagKeyDependentFlagsGetRequest($project_key, $feature_flag_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'flagsProjectKeyFeatureFlagKeyDependentFlagsGet'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function flagsProjectKeyFeatureFlagKeyDependentFlagsGetRequest($project_key, $feature_flag_key)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling flagsProjectKeyFeatureFlagKeyDependentFlagsGet'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling flagsProjectKeyFeatureFlagKeyDependentFlagsGet'
            );
        }

        $resourcePath = '/flags/{projectKey}/{featureFlagKey}/dependent-flags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApprovalRequest
     *
     * Get a single approval request for a feature flag config
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $approval_request_id The approval request ID (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\ApprovalRequests
     */
    public function getApprovalRequest($project_key, $feature_flag_key, $environment_key, $approval_request_id)
    {
        list($response) = $this->getApprovalRequestWithHttpInfo($project_key, $feature_flag_key, $environment_key, $approval_request_id);
        return $response;
    }

    /**
     * Operation getApprovalRequestWithHttpInfo
     *
     * Get a single approval request for a feature flag config
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $approval_request_id The approval request ID (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\ApprovalRequests, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApprovalRequestWithHttpInfo($project_key, $feature_flag_key, $environment_key, $approval_request_id)
    {
        $returnType = '\LaunchDarklyApi\Model\ApprovalRequests';
        $request = $this->getApprovalRequestRequest($project_key, $feature_flag_key, $environment_key, $approval_request_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\ApprovalRequests',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApprovalRequestAsync
     *
     * Get a single approval request for a feature flag config
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $approval_request_id The approval request ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApprovalRequestAsync($project_key, $feature_flag_key, $environment_key, $approval_request_id)
    {
        return $this->getApprovalRequestAsyncWithHttpInfo($project_key, $feature_flag_key, $environment_key, $approval_request_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApprovalRequestAsyncWithHttpInfo
     *
     * Get a single approval request for a feature flag config
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $approval_request_id The approval request ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApprovalRequestAsyncWithHttpInfo($project_key, $feature_flag_key, $environment_key, $approval_request_id)
    {
        $returnType = '\LaunchDarklyApi\Model\ApprovalRequests';
        $request = $this->getApprovalRequestRequest($project_key, $feature_flag_key, $environment_key, $approval_request_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApprovalRequest'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $approval_request_id The approval request ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApprovalRequestRequest($project_key, $feature_flag_key, $environment_key, $approval_request_id)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling getApprovalRequest'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling getApprovalRequest'
            );
        }
        // verify the required parameter 'environment_key' is set
        if ($environment_key === null || (is_array($environment_key) && count($environment_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_key when calling getApprovalRequest'
            );
        }
        // verify the required parameter 'approval_request_id' is set
        if ($approval_request_id === null || (is_array($approval_request_id) && count($approval_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $approval_request_id when calling getApprovalRequest'
            );
        }

        $resourcePath = '/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{approvalRequestId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }
        // path params
        if ($environment_key !== null) {
            $resourcePath = str_replace(
                '{' . 'environmentKey' . '}',
                ObjectSerializer::toPathValue($environment_key),
                $resourcePath
            );
        }
        // path params
        if ($approval_request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'approvalRequestId' . '}',
                ObjectSerializer::toPathValue($approval_request_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApprovalRequests
     *
     * Get all approval requests for a feature flag config
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\ApprovalRequests
     */
    public function getApprovalRequests($project_key, $feature_flag_key, $environment_key)
    {
        list($response) = $this->getApprovalRequestsWithHttpInfo($project_key, $feature_flag_key, $environment_key);
        return $response;
    }

    /**
     * Operation getApprovalRequestsWithHttpInfo
     *
     * Get all approval requests for a feature flag config
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\ApprovalRequests, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApprovalRequestsWithHttpInfo($project_key, $feature_flag_key, $environment_key)
    {
        $returnType = '\LaunchDarklyApi\Model\ApprovalRequests';
        $request = $this->getApprovalRequestsRequest($project_key, $feature_flag_key, $environment_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\ApprovalRequests',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApprovalRequestsAsync
     *
     * Get all approval requests for a feature flag config
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApprovalRequestsAsync($project_key, $feature_flag_key, $environment_key)
    {
        return $this->getApprovalRequestsAsyncWithHttpInfo($project_key, $feature_flag_key, $environment_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApprovalRequestsAsyncWithHttpInfo
     *
     * Get all approval requests for a feature flag config
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApprovalRequestsAsyncWithHttpInfo($project_key, $feature_flag_key, $environment_key)
    {
        $returnType = '\LaunchDarklyApi\Model\ApprovalRequests';
        $request = $this->getApprovalRequestsRequest($project_key, $feature_flag_key, $environment_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApprovalRequests'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApprovalRequestsRequest($project_key, $feature_flag_key, $environment_key)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling getApprovalRequests'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling getApprovalRequests'
            );
        }
        // verify the required parameter 'environment_key' is set
        if ($environment_key === null || (is_array($environment_key) && count($environment_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_key when calling getApprovalRequests'
            );
        }

        $resourcePath = '/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }
        // path params
        if ($environment_key !== null) {
            $resourcePath = str_replace(
                '{' . 'environmentKey' . '}',
                ObjectSerializer::toPathValue($environment_key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getExpiringUserTargets
     *
     * Get expiring user targets for feature flag
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\UserTargetingExpirationForFlags
     */
    public function getExpiringUserTargets($project_key, $environment_key, $feature_flag_key)
    {
        list($response) = $this->getExpiringUserTargetsWithHttpInfo($project_key, $environment_key, $feature_flag_key);
        return $response;
    }

    /**
     * Operation getExpiringUserTargetsWithHttpInfo
     *
     * Get expiring user targets for feature flag
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\UserTargetingExpirationForFlags, HTTP status code, HTTP response headers (array of strings)
     */
    public function getExpiringUserTargetsWithHttpInfo($project_key, $environment_key, $feature_flag_key)
    {
        $returnType = '\LaunchDarklyApi\Model\UserTargetingExpirationForFlags';
        $request = $this->getExpiringUserTargetsRequest($project_key, $environment_key, $feature_flag_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\UserTargetingExpirationForFlags',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getExpiringUserTargetsAsync
     *
     * Get expiring user targets for feature flag
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExpiringUserTargetsAsync($project_key, $environment_key, $feature_flag_key)
    {
        return $this->getExpiringUserTargetsAsyncWithHttpInfo($project_key, $environment_key, $feature_flag_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getExpiringUserTargetsAsyncWithHttpInfo
     *
     * Get expiring user targets for feature flag
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExpiringUserTargetsAsyncWithHttpInfo($project_key, $environment_key, $feature_flag_key)
    {
        $returnType = '\LaunchDarklyApi\Model\UserTargetingExpirationForFlags';
        $request = $this->getExpiringUserTargetsRequest($project_key, $environment_key, $feature_flag_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getExpiringUserTargets'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getExpiringUserTargetsRequest($project_key, $environment_key, $feature_flag_key)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling getExpiringUserTargets'
            );
        }
        // verify the required parameter 'environment_key' is set
        if ($environment_key === null || (is_array($environment_key) && count($environment_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_key when calling getExpiringUserTargets'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling getExpiringUserTargets'
            );
        }

        $resourcePath = '/flags/{projectKey}/{featureFlagKey}/expiring-user-targets/{environmentKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($environment_key !== null) {
            $resourcePath = str_replace(
                '{' . 'environmentKey' . '}',
                ObjectSerializer::toPathValue($environment_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFeatureFlag
     *
     * Get a single feature flag by key.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string[] $env By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment. (optional)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\FeatureFlag
     */
    public function getFeatureFlag($project_key, $feature_flag_key, $env = null)
    {
        list($response) = $this->getFeatureFlagWithHttpInfo($project_key, $feature_flag_key, $env);
        return $response;
    }

    /**
     * Operation getFeatureFlagWithHttpInfo
     *
     * Get a single feature flag by key.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string[] $env By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment. (optional)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\FeatureFlag, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFeatureFlagWithHttpInfo($project_key, $feature_flag_key, $env = null)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlag';
        $request = $this->getFeatureFlagRequest($project_key, $feature_flag_key, $env);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\FeatureFlag',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFeatureFlagAsync
     *
     * Get a single feature flag by key.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string[] $env By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureFlagAsync($project_key, $feature_flag_key, $env = null)
    {
        return $this->getFeatureFlagAsyncWithHttpInfo($project_key, $feature_flag_key, $env)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFeatureFlagAsyncWithHttpInfo
     *
     * Get a single feature flag by key.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string[] $env By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureFlagAsyncWithHttpInfo($project_key, $feature_flag_key, $env = null)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlag';
        $request = $this->getFeatureFlagRequest($project_key, $feature_flag_key, $env);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFeatureFlag'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string[] $env By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFeatureFlagRequest($project_key, $feature_flag_key, $env = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling getFeatureFlag'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling getFeatureFlag'
            );
        }

        $resourcePath = '/flags/{projectKey}/{featureFlagKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($env)) {
            $queryParams['env'] = $env;
        } else
        if ($env !== null) {
            $queryParams['env'] = ObjectSerializer::toQueryValue($env);
        }

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFeatureFlagStatus
     *
     * Get the status for a particular feature flag.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\FeatureFlagStatus
     */
    public function getFeatureFlagStatus($project_key, $environment_key, $feature_flag_key)
    {
        list($response) = $this->getFeatureFlagStatusWithHttpInfo($project_key, $environment_key, $feature_flag_key);
        return $response;
    }

    /**
     * Operation getFeatureFlagStatusWithHttpInfo
     *
     * Get the status for a particular feature flag.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\FeatureFlagStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFeatureFlagStatusWithHttpInfo($project_key, $environment_key, $feature_flag_key)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlagStatus';
        $request = $this->getFeatureFlagStatusRequest($project_key, $environment_key, $feature_flag_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\FeatureFlagStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFeatureFlagStatusAsync
     *
     * Get the status for a particular feature flag.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureFlagStatusAsync($project_key, $environment_key, $feature_flag_key)
    {
        return $this->getFeatureFlagStatusAsyncWithHttpInfo($project_key, $environment_key, $feature_flag_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFeatureFlagStatusAsyncWithHttpInfo
     *
     * Get the status for a particular feature flag.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureFlagStatusAsyncWithHttpInfo($project_key, $environment_key, $feature_flag_key)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlagStatus';
        $request = $this->getFeatureFlagStatusRequest($project_key, $environment_key, $feature_flag_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFeatureFlagStatus'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFeatureFlagStatusRequest($project_key, $environment_key, $feature_flag_key)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling getFeatureFlagStatus'
            );
        }
        // verify the required parameter 'environment_key' is set
        if ($environment_key === null || (is_array($environment_key) && count($environment_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_key when calling getFeatureFlagStatus'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling getFeatureFlagStatus'
            );
        }

        $resourcePath = '/flag-statuses/{projectKey}/{environmentKey}/{featureFlagKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($environment_key !== null) {
            $resourcePath = str_replace(
                '{' . 'environmentKey' . '}',
                ObjectSerializer::toPathValue($environment_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFeatureFlagStatusAcrossEnvironments
     *
     * Get the status for a particular feature flag across environments
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\FeatureFlagStatusAcrossEnvironments
     */
    public function getFeatureFlagStatusAcrossEnvironments($project_key, $feature_flag_key)
    {
        list($response) = $this->getFeatureFlagStatusAcrossEnvironmentsWithHttpInfo($project_key, $feature_flag_key);
        return $response;
    }

    /**
     * Operation getFeatureFlagStatusAcrossEnvironmentsWithHttpInfo
     *
     * Get the status for a particular feature flag across environments
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\FeatureFlagStatusAcrossEnvironments, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFeatureFlagStatusAcrossEnvironmentsWithHttpInfo($project_key, $feature_flag_key)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlagStatusAcrossEnvironments';
        $request = $this->getFeatureFlagStatusAcrossEnvironmentsRequest($project_key, $feature_flag_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\FeatureFlagStatusAcrossEnvironments',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\UsageError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFeatureFlagStatusAcrossEnvironmentsAsync
     *
     * Get the status for a particular feature flag across environments
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureFlagStatusAcrossEnvironmentsAsync($project_key, $feature_flag_key)
    {
        return $this->getFeatureFlagStatusAcrossEnvironmentsAsyncWithHttpInfo($project_key, $feature_flag_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFeatureFlagStatusAcrossEnvironmentsAsyncWithHttpInfo
     *
     * Get the status for a particular feature flag across environments
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureFlagStatusAcrossEnvironmentsAsyncWithHttpInfo($project_key, $feature_flag_key)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlagStatusAcrossEnvironments';
        $request = $this->getFeatureFlagStatusAcrossEnvironmentsRequest($project_key, $feature_flag_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFeatureFlagStatusAcrossEnvironments'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFeatureFlagStatusAcrossEnvironmentsRequest($project_key, $feature_flag_key)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling getFeatureFlagStatusAcrossEnvironments'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling getFeatureFlagStatusAcrossEnvironments'
            );
        }

        $resourcePath = '/flag-status/{projectKey}/{featureFlagKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFeatureFlagStatuses
     *
     * Get a list of statuses for all feature flags. The status includes the last time the feature flag was requested, as well as the state of the flag.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\FeatureFlagStatuses
     */
    public function getFeatureFlagStatuses($project_key, $environment_key)
    {
        list($response) = $this->getFeatureFlagStatusesWithHttpInfo($project_key, $environment_key);
        return $response;
    }

    /**
     * Operation getFeatureFlagStatusesWithHttpInfo
     *
     * Get a list of statuses for all feature flags. The status includes the last time the feature flag was requested, as well as the state of the flag.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\FeatureFlagStatuses, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFeatureFlagStatusesWithHttpInfo($project_key, $environment_key)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlagStatuses';
        $request = $this->getFeatureFlagStatusesRequest($project_key, $environment_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\FeatureFlagStatuses',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFeatureFlagStatusesAsync
     *
     * Get a list of statuses for all feature flags. The status includes the last time the feature flag was requested, as well as the state of the flag.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureFlagStatusesAsync($project_key, $environment_key)
    {
        return $this->getFeatureFlagStatusesAsyncWithHttpInfo($project_key, $environment_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFeatureFlagStatusesAsyncWithHttpInfo
     *
     * Get a list of statuses for all feature flags. The status includes the last time the feature flag was requested, as well as the state of the flag.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureFlagStatusesAsyncWithHttpInfo($project_key, $environment_key)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlagStatuses';
        $request = $this->getFeatureFlagStatusesRequest($project_key, $environment_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFeatureFlagStatuses'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFeatureFlagStatusesRequest($project_key, $environment_key)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling getFeatureFlagStatuses'
            );
        }
        // verify the required parameter 'environment_key' is set
        if ($environment_key === null || (is_array($environment_key) && count($environment_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_key when calling getFeatureFlagStatuses'
            );
        }

        $resourcePath = '/flag-statuses/{projectKey}/{environmentKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($environment_key !== null) {
            $resourcePath = str_replace(
                '{' . 'environmentKey' . '}',
                ObjectSerializer::toPathValue($environment_key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFeatureFlags
     *
     * Get a list of all features in the given project.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string[] $env By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment. (optional)
     * @param  bool $summary By default in api version &gt;&#x3D; 1, flags will _not_ include their list of prerequisites, targets or rules.  Set summary&#x3D;0 to include these fields for each flag returned. (optional)
     * @param  bool $archived When set to 1, only archived flags will be included in the list of flags returned.  By default, archived flags are not included in the list of flags. (optional)
     * @param  float $limit The number of objects to return. Defaults to -1, which returns everything. (optional)
     * @param  float $offset Where to start in the list. This is for use with pagination. For example, an offset of 10 would skip the first 10 items and then return the next limit items. (optional)
     * @param  string $filter A comma-separated list of filters. Each filter is of the form field:value. (optional)
     * @param  string $sort A comma-separated list of fields to sort by. A field prefixed by a - will be sorted in descending order. (optional)
     * @param  string $tag Filter by tag. A tag can be used to group flags across projects. (optional)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\FeatureFlags
     */
    public function getFeatureFlags($project_key, $env = null, $summary = null, $archived = null, $limit = null, $offset = null, $filter = null, $sort = null, $tag = null)
    {
        list($response) = $this->getFeatureFlagsWithHttpInfo($project_key, $env, $summary, $archived, $limit, $offset, $filter, $sort, $tag);
        return $response;
    }

    /**
     * Operation getFeatureFlagsWithHttpInfo
     *
     * Get a list of all features in the given project.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string[] $env By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment. (optional)
     * @param  bool $summary By default in api version &gt;&#x3D; 1, flags will _not_ include their list of prerequisites, targets or rules.  Set summary&#x3D;0 to include these fields for each flag returned. (optional)
     * @param  bool $archived When set to 1, only archived flags will be included in the list of flags returned.  By default, archived flags are not included in the list of flags. (optional)
     * @param  float $limit The number of objects to return. Defaults to -1, which returns everything. (optional)
     * @param  float $offset Where to start in the list. This is for use with pagination. For example, an offset of 10 would skip the first 10 items and then return the next limit items. (optional)
     * @param  string $filter A comma-separated list of filters. Each filter is of the form field:value. (optional)
     * @param  string $sort A comma-separated list of fields to sort by. A field prefixed by a - will be sorted in descending order. (optional)
     * @param  string $tag Filter by tag. A tag can be used to group flags across projects. (optional)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\FeatureFlags, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFeatureFlagsWithHttpInfo($project_key, $env = null, $summary = null, $archived = null, $limit = null, $offset = null, $filter = null, $sort = null, $tag = null)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlags';
        $request = $this->getFeatureFlagsRequest($project_key, $env, $summary, $archived, $limit, $offset, $filter, $sort, $tag);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\FeatureFlags',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFeatureFlagsAsync
     *
     * Get a list of all features in the given project.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string[] $env By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment. (optional)
     * @param  bool $summary By default in api version &gt;&#x3D; 1, flags will _not_ include their list of prerequisites, targets or rules.  Set summary&#x3D;0 to include these fields for each flag returned. (optional)
     * @param  bool $archived When set to 1, only archived flags will be included in the list of flags returned.  By default, archived flags are not included in the list of flags. (optional)
     * @param  float $limit The number of objects to return. Defaults to -1, which returns everything. (optional)
     * @param  float $offset Where to start in the list. This is for use with pagination. For example, an offset of 10 would skip the first 10 items and then return the next limit items. (optional)
     * @param  string $filter A comma-separated list of filters. Each filter is of the form field:value. (optional)
     * @param  string $sort A comma-separated list of fields to sort by. A field prefixed by a - will be sorted in descending order. (optional)
     * @param  string $tag Filter by tag. A tag can be used to group flags across projects. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureFlagsAsync($project_key, $env = null, $summary = null, $archived = null, $limit = null, $offset = null, $filter = null, $sort = null, $tag = null)
    {
        return $this->getFeatureFlagsAsyncWithHttpInfo($project_key, $env, $summary, $archived, $limit, $offset, $filter, $sort, $tag)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFeatureFlagsAsyncWithHttpInfo
     *
     * Get a list of all features in the given project.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string[] $env By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment. (optional)
     * @param  bool $summary By default in api version &gt;&#x3D; 1, flags will _not_ include their list of prerequisites, targets or rules.  Set summary&#x3D;0 to include these fields for each flag returned. (optional)
     * @param  bool $archived When set to 1, only archived flags will be included in the list of flags returned.  By default, archived flags are not included in the list of flags. (optional)
     * @param  float $limit The number of objects to return. Defaults to -1, which returns everything. (optional)
     * @param  float $offset Where to start in the list. This is for use with pagination. For example, an offset of 10 would skip the first 10 items and then return the next limit items. (optional)
     * @param  string $filter A comma-separated list of filters. Each filter is of the form field:value. (optional)
     * @param  string $sort A comma-separated list of fields to sort by. A field prefixed by a - will be sorted in descending order. (optional)
     * @param  string $tag Filter by tag. A tag can be used to group flags across projects. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFeatureFlagsAsyncWithHttpInfo($project_key, $env = null, $summary = null, $archived = null, $limit = null, $offset = null, $filter = null, $sort = null, $tag = null)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlags';
        $request = $this->getFeatureFlagsRequest($project_key, $env, $summary, $archived, $limit, $offset, $filter, $sort, $tag);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFeatureFlags'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string[] $env By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment. (optional)
     * @param  bool $summary By default in api version &gt;&#x3D; 1, flags will _not_ include their list of prerequisites, targets or rules.  Set summary&#x3D;0 to include these fields for each flag returned. (optional)
     * @param  bool $archived When set to 1, only archived flags will be included in the list of flags returned.  By default, archived flags are not included in the list of flags. (optional)
     * @param  float $limit The number of objects to return. Defaults to -1, which returns everything. (optional)
     * @param  float $offset Where to start in the list. This is for use with pagination. For example, an offset of 10 would skip the first 10 items and then return the next limit items. (optional)
     * @param  string $filter A comma-separated list of filters. Each filter is of the form field:value. (optional)
     * @param  string $sort A comma-separated list of fields to sort by. A field prefixed by a - will be sorted in descending order. (optional)
     * @param  string $tag Filter by tag. A tag can be used to group flags across projects. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFeatureFlagsRequest($project_key, $env = null, $summary = null, $archived = null, $limit = null, $offset = null, $filter = null, $sort = null, $tag = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling getFeatureFlags'
            );
        }

        $resourcePath = '/flags/{projectKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($env)) {
            $queryParams['env'] = $env;
        } else
        if ($env !== null) {
            $queryParams['env'] = ObjectSerializer::toQueryValue($env);
        }
        // query params
        if ($summary !== null) {
            $queryParams['summary'] = ObjectSerializer::toQueryValue($summary);
        }
        // query params
        if ($archived !== null) {
            $queryParams['archived'] = ObjectSerializer::toQueryValue($archived);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($filter !== null) {
            $queryParams['filter'] = ObjectSerializer::toQueryValue($filter);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($tag !== null) {
            $queryParams['tag'] = ObjectSerializer::toQueryValue($tag);
        }

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFlagConfigScheduledChange
     *
     * Get a scheduled change on a feature flag by id.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $scheduled_change_id The id of the scheduled change (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\FeatureFlagScheduledChange
     */
    public function getFlagConfigScheduledChange($project_key, $feature_flag_key, $environment_key, $scheduled_change_id)
    {
        list($response) = $this->getFlagConfigScheduledChangeWithHttpInfo($project_key, $feature_flag_key, $environment_key, $scheduled_change_id);
        return $response;
    }

    /**
     * Operation getFlagConfigScheduledChangeWithHttpInfo
     *
     * Get a scheduled change on a feature flag by id.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $scheduled_change_id The id of the scheduled change (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\FeatureFlagScheduledChange, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFlagConfigScheduledChangeWithHttpInfo($project_key, $feature_flag_key, $environment_key, $scheduled_change_id)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlagScheduledChange';
        $request = $this->getFlagConfigScheduledChangeRequest($project_key, $feature_flag_key, $environment_key, $scheduled_change_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\FeatureFlagScheduledChange',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFlagConfigScheduledChangeAsync
     *
     * Get a scheduled change on a feature flag by id.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $scheduled_change_id The id of the scheduled change (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFlagConfigScheduledChangeAsync($project_key, $feature_flag_key, $environment_key, $scheduled_change_id)
    {
        return $this->getFlagConfigScheduledChangeAsyncWithHttpInfo($project_key, $feature_flag_key, $environment_key, $scheduled_change_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFlagConfigScheduledChangeAsyncWithHttpInfo
     *
     * Get a scheduled change on a feature flag by id.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $scheduled_change_id The id of the scheduled change (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFlagConfigScheduledChangeAsyncWithHttpInfo($project_key, $feature_flag_key, $environment_key, $scheduled_change_id)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlagScheduledChange';
        $request = $this->getFlagConfigScheduledChangeRequest($project_key, $feature_flag_key, $environment_key, $scheduled_change_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFlagConfigScheduledChange'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $scheduled_change_id The id of the scheduled change (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFlagConfigScheduledChangeRequest($project_key, $feature_flag_key, $environment_key, $scheduled_change_id)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling getFlagConfigScheduledChange'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling getFlagConfigScheduledChange'
            );
        }
        // verify the required parameter 'environment_key' is set
        if ($environment_key === null || (is_array($environment_key) && count($environment_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_key when calling getFlagConfigScheduledChange'
            );
        }
        // verify the required parameter 'scheduled_change_id' is set
        if ($scheduled_change_id === null || (is_array($scheduled_change_id) && count($scheduled_change_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $scheduled_change_id when calling getFlagConfigScheduledChange'
            );
        }

        $resourcePath = '/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes/{scheduledChangeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }
        // path params
        if ($environment_key !== null) {
            $resourcePath = str_replace(
                '{' . 'environmentKey' . '}',
                ObjectSerializer::toPathValue($environment_key),
                $resourcePath
            );
        }
        // path params
        if ($scheduled_change_id !== null) {
            $resourcePath = str_replace(
                '{' . 'scheduledChangeId' . '}',
                ObjectSerializer::toPathValue($scheduled_change_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFlagConfigScheduledChanges
     *
     * Get all scheduled workflows for a feature flag by key.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\FeatureFlagScheduledChanges
     */
    public function getFlagConfigScheduledChanges($project_key, $feature_flag_key, $environment_key)
    {
        list($response) = $this->getFlagConfigScheduledChangesWithHttpInfo($project_key, $feature_flag_key, $environment_key);
        return $response;
    }

    /**
     * Operation getFlagConfigScheduledChangesWithHttpInfo
     *
     * Get all scheduled workflows for a feature flag by key.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\FeatureFlagScheduledChanges, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFlagConfigScheduledChangesWithHttpInfo($project_key, $feature_flag_key, $environment_key)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlagScheduledChanges';
        $request = $this->getFlagConfigScheduledChangesRequest($project_key, $feature_flag_key, $environment_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\FeatureFlagScheduledChanges',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFlagConfigScheduledChangesAsync
     *
     * Get all scheduled workflows for a feature flag by key.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFlagConfigScheduledChangesAsync($project_key, $feature_flag_key, $environment_key)
    {
        return $this->getFlagConfigScheduledChangesAsyncWithHttpInfo($project_key, $feature_flag_key, $environment_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFlagConfigScheduledChangesAsyncWithHttpInfo
     *
     * Get all scheduled workflows for a feature flag by key.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFlagConfigScheduledChangesAsyncWithHttpInfo($project_key, $feature_flag_key, $environment_key)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlagScheduledChanges';
        $request = $this->getFlagConfigScheduledChangesRequest($project_key, $feature_flag_key, $environment_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFlagConfigScheduledChanges'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFlagConfigScheduledChangesRequest($project_key, $feature_flag_key, $environment_key)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling getFlagConfigScheduledChanges'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling getFlagConfigScheduledChanges'
            );
        }
        // verify the required parameter 'environment_key' is set
        if ($environment_key === null || (is_array($environment_key) && count($environment_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_key when calling getFlagConfigScheduledChanges'
            );
        }

        $resourcePath = '/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }
        // path params
        if ($environment_key !== null) {
            $resourcePath = str_replace(
                '{' . 'environmentKey' . '}',
                ObjectSerializer::toPathValue($environment_key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFlagConfigScheduledChangesConflicts
     *
     * Lists conflicts between the given instructions and any existing scheduled changes for the feature flag. The actual HTTP verb should be REPORT, not POST.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  \LaunchDarklyApi\Model\FlagConfigScheduledChangesConflictsBody $flag_config_scheduled_changes_conflicts_body Used to determine if a semantic patch will result in conflicts with scheduled changes on a feature flag. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\FeatureFlagScheduledChangesConflicts
     */
    public function getFlagConfigScheduledChangesConflicts($project_key, $feature_flag_key, $environment_key, $flag_config_scheduled_changes_conflicts_body)
    {
        list($response) = $this->getFlagConfigScheduledChangesConflictsWithHttpInfo($project_key, $feature_flag_key, $environment_key, $flag_config_scheduled_changes_conflicts_body);
        return $response;
    }

    /**
     * Operation getFlagConfigScheduledChangesConflictsWithHttpInfo
     *
     * Lists conflicts between the given instructions and any existing scheduled changes for the feature flag. The actual HTTP verb should be REPORT, not POST.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  \LaunchDarklyApi\Model\FlagConfigScheduledChangesConflictsBody $flag_config_scheduled_changes_conflicts_body Used to determine if a semantic patch will result in conflicts with scheduled changes on a feature flag. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\FeatureFlagScheduledChangesConflicts, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFlagConfigScheduledChangesConflictsWithHttpInfo($project_key, $feature_flag_key, $environment_key, $flag_config_scheduled_changes_conflicts_body)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlagScheduledChangesConflicts';
        $request = $this->getFlagConfigScheduledChangesConflictsRequest($project_key, $feature_flag_key, $environment_key, $flag_config_scheduled_changes_conflicts_body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\FeatureFlagScheduledChangesConflicts',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFlagConfigScheduledChangesConflictsAsync
     *
     * Lists conflicts between the given instructions and any existing scheduled changes for the feature flag. The actual HTTP verb should be REPORT, not POST.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  \LaunchDarklyApi\Model\FlagConfigScheduledChangesConflictsBody $flag_config_scheduled_changes_conflicts_body Used to determine if a semantic patch will result in conflicts with scheduled changes on a feature flag. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFlagConfigScheduledChangesConflictsAsync($project_key, $feature_flag_key, $environment_key, $flag_config_scheduled_changes_conflicts_body)
    {
        return $this->getFlagConfigScheduledChangesConflictsAsyncWithHttpInfo($project_key, $feature_flag_key, $environment_key, $flag_config_scheduled_changes_conflicts_body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFlagConfigScheduledChangesConflictsAsyncWithHttpInfo
     *
     * Lists conflicts between the given instructions and any existing scheduled changes for the feature flag. The actual HTTP verb should be REPORT, not POST.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  \LaunchDarklyApi\Model\FlagConfigScheduledChangesConflictsBody $flag_config_scheduled_changes_conflicts_body Used to determine if a semantic patch will result in conflicts with scheduled changes on a feature flag. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFlagConfigScheduledChangesConflictsAsyncWithHttpInfo($project_key, $feature_flag_key, $environment_key, $flag_config_scheduled_changes_conflicts_body)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlagScheduledChangesConflicts';
        $request = $this->getFlagConfigScheduledChangesConflictsRequest($project_key, $feature_flag_key, $environment_key, $flag_config_scheduled_changes_conflicts_body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFlagConfigScheduledChangesConflicts'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  \LaunchDarklyApi\Model\FlagConfigScheduledChangesConflictsBody $flag_config_scheduled_changes_conflicts_body Used to determine if a semantic patch will result in conflicts with scheduled changes on a feature flag. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFlagConfigScheduledChangesConflictsRequest($project_key, $feature_flag_key, $environment_key, $flag_config_scheduled_changes_conflicts_body)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling getFlagConfigScheduledChangesConflicts'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling getFlagConfigScheduledChangesConflicts'
            );
        }
        // verify the required parameter 'environment_key' is set
        if ($environment_key === null || (is_array($environment_key) && count($environment_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_key when calling getFlagConfigScheduledChangesConflicts'
            );
        }
        // verify the required parameter 'flag_config_scheduled_changes_conflicts_body' is set
        if ($flag_config_scheduled_changes_conflicts_body === null || (is_array($flag_config_scheduled_changes_conflicts_body) && count($flag_config_scheduled_changes_conflicts_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flag_config_scheduled_changes_conflicts_body when calling getFlagConfigScheduledChangesConflicts'
            );
        }

        $resourcePath = '/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes-conflicts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }
        // path params
        if ($environment_key !== null) {
            $resourcePath = str_replace(
                '{' . 'environmentKey' . '}',
                ObjectSerializer::toPathValue($environment_key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($flag_config_scheduled_changes_conflicts_body)) {
            $_tempBody = $flag_config_scheduled_changes_conflicts_body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchExpiringUserTargets
     *
     * Update, add, or delete expiring user targets on feature flag
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  object $semantic_patch_with_comment Requires a Semantic Patch representation of the desired changes to the resource. &#39;https://apidocs.launchdarkly.com/reference#updates-via-semantic-patches&#39;. The addition of comments is also supported. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\UserTargetingExpirationForFlags
     */
    public function patchExpiringUserTargets($project_key, $environment_key, $feature_flag_key, $semantic_patch_with_comment)
    {
        list($response) = $this->patchExpiringUserTargetsWithHttpInfo($project_key, $environment_key, $feature_flag_key, $semantic_patch_with_comment);
        return $response;
    }

    /**
     * Operation patchExpiringUserTargetsWithHttpInfo
     *
     * Update, add, or delete expiring user targets on feature flag
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  object $semantic_patch_with_comment Requires a Semantic Patch representation of the desired changes to the resource. &#39;https://apidocs.launchdarkly.com/reference#updates-via-semantic-patches&#39;. The addition of comments is also supported. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\UserTargetingExpirationForFlags, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchExpiringUserTargetsWithHttpInfo($project_key, $environment_key, $feature_flag_key, $semantic_patch_with_comment)
    {
        $returnType = '\LaunchDarklyApi\Model\UserTargetingExpirationForFlags';
        $request = $this->patchExpiringUserTargetsRequest($project_key, $environment_key, $feature_flag_key, $semantic_patch_with_comment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\UserTargetingExpirationForFlags',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchExpiringUserTargetsAsync
     *
     * Update, add, or delete expiring user targets on feature flag
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  object $semantic_patch_with_comment Requires a Semantic Patch representation of the desired changes to the resource. &#39;https://apidocs.launchdarkly.com/reference#updates-via-semantic-patches&#39;. The addition of comments is also supported. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchExpiringUserTargetsAsync($project_key, $environment_key, $feature_flag_key, $semantic_patch_with_comment)
    {
        return $this->patchExpiringUserTargetsAsyncWithHttpInfo($project_key, $environment_key, $feature_flag_key, $semantic_patch_with_comment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchExpiringUserTargetsAsyncWithHttpInfo
     *
     * Update, add, or delete expiring user targets on feature flag
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  object $semantic_patch_with_comment Requires a Semantic Patch representation of the desired changes to the resource. &#39;https://apidocs.launchdarkly.com/reference#updates-via-semantic-patches&#39;. The addition of comments is also supported. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchExpiringUserTargetsAsyncWithHttpInfo($project_key, $environment_key, $feature_flag_key, $semantic_patch_with_comment)
    {
        $returnType = '\LaunchDarklyApi\Model\UserTargetingExpirationForFlags';
        $request = $this->patchExpiringUserTargetsRequest($project_key, $environment_key, $feature_flag_key, $semantic_patch_with_comment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchExpiringUserTargets'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  object $semantic_patch_with_comment Requires a Semantic Patch representation of the desired changes to the resource. &#39;https://apidocs.launchdarkly.com/reference#updates-via-semantic-patches&#39;. The addition of comments is also supported. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchExpiringUserTargetsRequest($project_key, $environment_key, $feature_flag_key, $semantic_patch_with_comment)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling patchExpiringUserTargets'
            );
        }
        // verify the required parameter 'environment_key' is set
        if ($environment_key === null || (is_array($environment_key) && count($environment_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_key when calling patchExpiringUserTargets'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling patchExpiringUserTargets'
            );
        }
        // verify the required parameter 'semantic_patch_with_comment' is set
        if ($semantic_patch_with_comment === null || (is_array($semantic_patch_with_comment) && count($semantic_patch_with_comment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $semantic_patch_with_comment when calling patchExpiringUserTargets'
            );
        }

        $resourcePath = '/flags/{projectKey}/{featureFlagKey}/expiring-user-targets/{environmentKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($environment_key !== null) {
            $resourcePath = str_replace(
                '{' . 'environmentKey' . '}',
                ObjectSerializer::toPathValue($environment_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($semantic_patch_with_comment)) {
            $_tempBody = $semantic_patch_with_comment;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchFeatureFlag
     *
     * Perform a partial update to a feature.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\PatchComment $patch_comment Requires a JSON Patch representation of the desired changes to the project, and an optional comment. &#39;http://jsonpatch.com/&#39; Feature flag patches also support JSON Merge Patch format. &#39;https://tools.ietf.org/html/rfc7386&#39; The addition of comments is also supported. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\FeatureFlag
     */
    public function patchFeatureFlag($project_key, $feature_flag_key, $patch_comment)
    {
        list($response) = $this->patchFeatureFlagWithHttpInfo($project_key, $feature_flag_key, $patch_comment);
        return $response;
    }

    /**
     * Operation patchFeatureFlagWithHttpInfo
     *
     * Perform a partial update to a feature.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\PatchComment $patch_comment Requires a JSON Patch representation of the desired changes to the project, and an optional comment. &#39;http://jsonpatch.com/&#39; Feature flag patches also support JSON Merge Patch format. &#39;https://tools.ietf.org/html/rfc7386&#39; The addition of comments is also supported. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\FeatureFlag, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchFeatureFlagWithHttpInfo($project_key, $feature_flag_key, $patch_comment)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlag';
        $request = $this->patchFeatureFlagRequest($project_key, $feature_flag_key, $patch_comment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\FeatureFlag',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchFeatureFlagAsync
     *
     * Perform a partial update to a feature.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\PatchComment $patch_comment Requires a JSON Patch representation of the desired changes to the project, and an optional comment. &#39;http://jsonpatch.com/&#39; Feature flag patches also support JSON Merge Patch format. &#39;https://tools.ietf.org/html/rfc7386&#39; The addition of comments is also supported. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchFeatureFlagAsync($project_key, $feature_flag_key, $patch_comment)
    {
        return $this->patchFeatureFlagAsyncWithHttpInfo($project_key, $feature_flag_key, $patch_comment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchFeatureFlagAsyncWithHttpInfo
     *
     * Perform a partial update to a feature.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\PatchComment $patch_comment Requires a JSON Patch representation of the desired changes to the project, and an optional comment. &#39;http://jsonpatch.com/&#39; Feature flag patches also support JSON Merge Patch format. &#39;https://tools.ietf.org/html/rfc7386&#39; The addition of comments is also supported. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchFeatureFlagAsyncWithHttpInfo($project_key, $feature_flag_key, $patch_comment)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlag';
        $request = $this->patchFeatureFlagRequest($project_key, $feature_flag_key, $patch_comment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchFeatureFlag'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\PatchComment $patch_comment Requires a JSON Patch representation of the desired changes to the project, and an optional comment. &#39;http://jsonpatch.com/&#39; Feature flag patches also support JSON Merge Patch format. &#39;https://tools.ietf.org/html/rfc7386&#39; The addition of comments is also supported. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchFeatureFlagRequest($project_key, $feature_flag_key, $patch_comment)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling patchFeatureFlag'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling patchFeatureFlag'
            );
        }
        // verify the required parameter 'patch_comment' is set
        if ($patch_comment === null || (is_array($patch_comment) && count($patch_comment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $patch_comment when calling patchFeatureFlag'
            );
        }

        $resourcePath = '/flags/{projectKey}/{featureFlagKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($patch_comment)) {
            $_tempBody = $patch_comment;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchFlagConfigScheduledChange
     *
     * Updates an existing scheduled-change on a feature flag in an environment.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\FlagConfigScheduledChangesPatchBody $flag_config_scheduled_changes_patch_body Update scheduled changes on a feature flag. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $scheduled_change_id The id of the scheduled change (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\FeatureFlagScheduledChange
     */
    public function patchFlagConfigScheduledChange($project_key, $feature_flag_key, $flag_config_scheduled_changes_patch_body, $environment_key, $scheduled_change_id)
    {
        list($response) = $this->patchFlagConfigScheduledChangeWithHttpInfo($project_key, $feature_flag_key, $flag_config_scheduled_changes_patch_body, $environment_key, $scheduled_change_id);
        return $response;
    }

    /**
     * Operation patchFlagConfigScheduledChangeWithHttpInfo
     *
     * Updates an existing scheduled-change on a feature flag in an environment.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\FlagConfigScheduledChangesPatchBody $flag_config_scheduled_changes_patch_body Update scheduled changes on a feature flag. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $scheduled_change_id The id of the scheduled change (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\FeatureFlagScheduledChange, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchFlagConfigScheduledChangeWithHttpInfo($project_key, $feature_flag_key, $flag_config_scheduled_changes_patch_body, $environment_key, $scheduled_change_id)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlagScheduledChange';
        $request = $this->patchFlagConfigScheduledChangeRequest($project_key, $feature_flag_key, $flag_config_scheduled_changes_patch_body, $environment_key, $scheduled_change_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\FeatureFlagScheduledChange',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchFlagConfigScheduledChangeAsync
     *
     * Updates an existing scheduled-change on a feature flag in an environment.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\FlagConfigScheduledChangesPatchBody $flag_config_scheduled_changes_patch_body Update scheduled changes on a feature flag. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $scheduled_change_id The id of the scheduled change (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchFlagConfigScheduledChangeAsync($project_key, $feature_flag_key, $flag_config_scheduled_changes_patch_body, $environment_key, $scheduled_change_id)
    {
        return $this->patchFlagConfigScheduledChangeAsyncWithHttpInfo($project_key, $feature_flag_key, $flag_config_scheduled_changes_patch_body, $environment_key, $scheduled_change_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchFlagConfigScheduledChangeAsyncWithHttpInfo
     *
     * Updates an existing scheduled-change on a feature flag in an environment.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\FlagConfigScheduledChangesPatchBody $flag_config_scheduled_changes_patch_body Update scheduled changes on a feature flag. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $scheduled_change_id The id of the scheduled change (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchFlagConfigScheduledChangeAsyncWithHttpInfo($project_key, $feature_flag_key, $flag_config_scheduled_changes_patch_body, $environment_key, $scheduled_change_id)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlagScheduledChange';
        $request = $this->patchFlagConfigScheduledChangeRequest($project_key, $feature_flag_key, $flag_config_scheduled_changes_patch_body, $environment_key, $scheduled_change_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchFlagConfigScheduledChange'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  \LaunchDarklyApi\Model\FlagConfigScheduledChangesPatchBody $flag_config_scheduled_changes_patch_body Update scheduled changes on a feature flag. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $scheduled_change_id The id of the scheduled change (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchFlagConfigScheduledChangeRequest($project_key, $feature_flag_key, $flag_config_scheduled_changes_patch_body, $environment_key, $scheduled_change_id)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling patchFlagConfigScheduledChange'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling patchFlagConfigScheduledChange'
            );
        }
        // verify the required parameter 'flag_config_scheduled_changes_patch_body' is set
        if ($flag_config_scheduled_changes_patch_body === null || (is_array($flag_config_scheduled_changes_patch_body) && count($flag_config_scheduled_changes_patch_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flag_config_scheduled_changes_patch_body when calling patchFlagConfigScheduledChange'
            );
        }
        // verify the required parameter 'environment_key' is set
        if ($environment_key === null || (is_array($environment_key) && count($environment_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_key when calling patchFlagConfigScheduledChange'
            );
        }
        // verify the required parameter 'scheduled_change_id' is set
        if ($scheduled_change_id === null || (is_array($scheduled_change_id) && count($scheduled_change_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $scheduled_change_id when calling patchFlagConfigScheduledChange'
            );
        }

        $resourcePath = '/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes/{scheduledChangeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }
        // path params
        if ($environment_key !== null) {
            $resourcePath = str_replace(
                '{' . 'environmentKey' . '}',
                ObjectSerializer::toPathValue($environment_key),
                $resourcePath
            );
        }
        // path params
        if ($scheduled_change_id !== null) {
            $resourcePath = str_replace(
                '{' . 'scheduledChangeId' . '}',
                ObjectSerializer::toPathValue($scheduled_change_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($flag_config_scheduled_changes_patch_body)) {
            $_tempBody = $flag_config_scheduled_changes_patch_body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApplyApprovalRequest
     *
     * Apply approval request for a feature flag config
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $approval_request_id The approval request ID (required)
     * @param  \LaunchDarklyApi\Model\ApprovalRequestApplyConfigBody $approval_request_apply_config_body Apply an approval request (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\ApprovalRequests
     */
    public function postApplyApprovalRequest($project_key, $feature_flag_key, $environment_key, $approval_request_id, $approval_request_apply_config_body)
    {
        list($response) = $this->postApplyApprovalRequestWithHttpInfo($project_key, $feature_flag_key, $environment_key, $approval_request_id, $approval_request_apply_config_body);
        return $response;
    }

    /**
     * Operation postApplyApprovalRequestWithHttpInfo
     *
     * Apply approval request for a feature flag config
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $approval_request_id The approval request ID (required)
     * @param  \LaunchDarklyApi\Model\ApprovalRequestApplyConfigBody $approval_request_apply_config_body Apply an approval request (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\ApprovalRequests, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApplyApprovalRequestWithHttpInfo($project_key, $feature_flag_key, $environment_key, $approval_request_id, $approval_request_apply_config_body)
    {
        $returnType = '\LaunchDarklyApi\Model\ApprovalRequests';
        $request = $this->postApplyApprovalRequestRequest($project_key, $feature_flag_key, $environment_key, $approval_request_id, $approval_request_apply_config_body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\ApprovalRequests',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApplyApprovalRequestAsync
     *
     * Apply approval request for a feature flag config
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $approval_request_id The approval request ID (required)
     * @param  \LaunchDarklyApi\Model\ApprovalRequestApplyConfigBody $approval_request_apply_config_body Apply an approval request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApplyApprovalRequestAsync($project_key, $feature_flag_key, $environment_key, $approval_request_id, $approval_request_apply_config_body)
    {
        return $this->postApplyApprovalRequestAsyncWithHttpInfo($project_key, $feature_flag_key, $environment_key, $approval_request_id, $approval_request_apply_config_body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApplyApprovalRequestAsyncWithHttpInfo
     *
     * Apply approval request for a feature flag config
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $approval_request_id The approval request ID (required)
     * @param  \LaunchDarklyApi\Model\ApprovalRequestApplyConfigBody $approval_request_apply_config_body Apply an approval request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApplyApprovalRequestAsyncWithHttpInfo($project_key, $feature_flag_key, $environment_key, $approval_request_id, $approval_request_apply_config_body)
    {
        $returnType = '\LaunchDarklyApi\Model\ApprovalRequests';
        $request = $this->postApplyApprovalRequestRequest($project_key, $feature_flag_key, $environment_key, $approval_request_id, $approval_request_apply_config_body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApplyApprovalRequest'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $approval_request_id The approval request ID (required)
     * @param  \LaunchDarklyApi\Model\ApprovalRequestApplyConfigBody $approval_request_apply_config_body Apply an approval request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApplyApprovalRequestRequest($project_key, $feature_flag_key, $environment_key, $approval_request_id, $approval_request_apply_config_body)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling postApplyApprovalRequest'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling postApplyApprovalRequest'
            );
        }
        // verify the required parameter 'environment_key' is set
        if ($environment_key === null || (is_array($environment_key) && count($environment_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_key when calling postApplyApprovalRequest'
            );
        }
        // verify the required parameter 'approval_request_id' is set
        if ($approval_request_id === null || (is_array($approval_request_id) && count($approval_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $approval_request_id when calling postApplyApprovalRequest'
            );
        }
        // verify the required parameter 'approval_request_apply_config_body' is set
        if ($approval_request_apply_config_body === null || (is_array($approval_request_apply_config_body) && count($approval_request_apply_config_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $approval_request_apply_config_body when calling postApplyApprovalRequest'
            );
        }

        $resourcePath = '/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{approvalRequestId}/apply';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }
        // path params
        if ($environment_key !== null) {
            $resourcePath = str_replace(
                '{' . 'environmentKey' . '}',
                ObjectSerializer::toPathValue($environment_key),
                $resourcePath
            );
        }
        // path params
        if ($approval_request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'approvalRequestId' . '}',
                ObjectSerializer::toPathValue($approval_request_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($approval_request_apply_config_body)) {
            $_tempBody = $approval_request_apply_config_body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApprovalRequest
     *
     * Create an approval request for a feature flag config
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $approval_request_id The approval request ID (required)
     * @param  \LaunchDarklyApi\Model\ApprovalRequestConfigBody $approval_request_config_body Create a new approval request (optional)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\ApprovalRequest
     */
    public function postApprovalRequest($project_key, $feature_flag_key, $environment_key, $approval_request_id, $approval_request_config_body = null)
    {
        list($response) = $this->postApprovalRequestWithHttpInfo($project_key, $feature_flag_key, $environment_key, $approval_request_id, $approval_request_config_body);
        return $response;
    }

    /**
     * Operation postApprovalRequestWithHttpInfo
     *
     * Create an approval request for a feature flag config
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $approval_request_id The approval request ID (required)
     * @param  \LaunchDarklyApi\Model\ApprovalRequestConfigBody $approval_request_config_body Create a new approval request (optional)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\ApprovalRequest, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApprovalRequestWithHttpInfo($project_key, $feature_flag_key, $environment_key, $approval_request_id, $approval_request_config_body = null)
    {
        $returnType = '\LaunchDarklyApi\Model\ApprovalRequest';
        $request = $this->postApprovalRequestRequest($project_key, $feature_flag_key, $environment_key, $approval_request_id, $approval_request_config_body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\ApprovalRequest',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApprovalRequestAsync
     *
     * Create an approval request for a feature flag config
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $approval_request_id The approval request ID (required)
     * @param  \LaunchDarklyApi\Model\ApprovalRequestConfigBody $approval_request_config_body Create a new approval request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApprovalRequestAsync($project_key, $feature_flag_key, $environment_key, $approval_request_id, $approval_request_config_body = null)
    {
        return $this->postApprovalRequestAsyncWithHttpInfo($project_key, $feature_flag_key, $environment_key, $approval_request_id, $approval_request_config_body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApprovalRequestAsyncWithHttpInfo
     *
     * Create an approval request for a feature flag config
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $approval_request_id The approval request ID (required)
     * @param  \LaunchDarklyApi\Model\ApprovalRequestConfigBody $approval_request_config_body Create a new approval request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApprovalRequestAsyncWithHttpInfo($project_key, $feature_flag_key, $environment_key, $approval_request_id, $approval_request_config_body = null)
    {
        $returnType = '\LaunchDarklyApi\Model\ApprovalRequest';
        $request = $this->postApprovalRequestRequest($project_key, $feature_flag_key, $environment_key, $approval_request_id, $approval_request_config_body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApprovalRequest'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $approval_request_id The approval request ID (required)
     * @param  \LaunchDarklyApi\Model\ApprovalRequestConfigBody $approval_request_config_body Create a new approval request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApprovalRequestRequest($project_key, $feature_flag_key, $environment_key, $approval_request_id, $approval_request_config_body = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling postApprovalRequest'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling postApprovalRequest'
            );
        }
        // verify the required parameter 'environment_key' is set
        if ($environment_key === null || (is_array($environment_key) && count($environment_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_key when calling postApprovalRequest'
            );
        }
        // verify the required parameter 'approval_request_id' is set
        if ($approval_request_id === null || (is_array($approval_request_id) && count($approval_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $approval_request_id when calling postApprovalRequest'
            );
        }

        $resourcePath = '/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{approvalRequestId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }
        // path params
        if ($environment_key !== null) {
            $resourcePath = str_replace(
                '{' . 'environmentKey' . '}',
                ObjectSerializer::toPathValue($environment_key),
                $resourcePath
            );
        }
        // path params
        if ($approval_request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'approvalRequestId' . '}',
                ObjectSerializer::toPathValue($approval_request_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($approval_request_config_body)) {
            $_tempBody = $approval_request_config_body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postFeatureFlag
     *
     * Creates a new feature flag.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  \LaunchDarklyApi\Model\FeatureFlagBody $feature_flag_body Create a new feature flag. (required)
     * @param  string $clone The key of the feature flag to be cloned. The key identifies the flag in your code.  For example, setting clone&#x3D;flagKey will copy the full targeting configuration for all environments (including on/off state) from the original flag to the new flag. (optional)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\FeatureFlag
     */
    public function postFeatureFlag($project_key, $feature_flag_body, $clone = null)
    {
        list($response) = $this->postFeatureFlagWithHttpInfo($project_key, $feature_flag_body, $clone);
        return $response;
    }

    /**
     * Operation postFeatureFlagWithHttpInfo
     *
     * Creates a new feature flag.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  \LaunchDarklyApi\Model\FeatureFlagBody $feature_flag_body Create a new feature flag. (required)
     * @param  string $clone The key of the feature flag to be cloned. The key identifies the flag in your code.  For example, setting clone&#x3D;flagKey will copy the full targeting configuration for all environments (including on/off state) from the original flag to the new flag. (optional)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\FeatureFlag, HTTP status code, HTTP response headers (array of strings)
     */
    public function postFeatureFlagWithHttpInfo($project_key, $feature_flag_body, $clone = null)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlag';
        $request = $this->postFeatureFlagRequest($project_key, $feature_flag_body, $clone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\FeatureFlag',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postFeatureFlagAsync
     *
     * Creates a new feature flag.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  \LaunchDarklyApi\Model\FeatureFlagBody $feature_flag_body Create a new feature flag. (required)
     * @param  string $clone The key of the feature flag to be cloned. The key identifies the flag in your code.  For example, setting clone&#x3D;flagKey will copy the full targeting configuration for all environments (including on/off state) from the original flag to the new flag. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postFeatureFlagAsync($project_key, $feature_flag_body, $clone = null)
    {
        return $this->postFeatureFlagAsyncWithHttpInfo($project_key, $feature_flag_body, $clone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postFeatureFlagAsyncWithHttpInfo
     *
     * Creates a new feature flag.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  \LaunchDarklyApi\Model\FeatureFlagBody $feature_flag_body Create a new feature flag. (required)
     * @param  string $clone The key of the feature flag to be cloned. The key identifies the flag in your code.  For example, setting clone&#x3D;flagKey will copy the full targeting configuration for all environments (including on/off state) from the original flag to the new flag. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postFeatureFlagAsyncWithHttpInfo($project_key, $feature_flag_body, $clone = null)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlag';
        $request = $this->postFeatureFlagRequest($project_key, $feature_flag_body, $clone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postFeatureFlag'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  \LaunchDarklyApi\Model\FeatureFlagBody $feature_flag_body Create a new feature flag. (required)
     * @param  string $clone The key of the feature flag to be cloned. The key identifies the flag in your code.  For example, setting clone&#x3D;flagKey will copy the full targeting configuration for all environments (including on/off state) from the original flag to the new flag. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postFeatureFlagRequest($project_key, $feature_flag_body, $clone = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling postFeatureFlag'
            );
        }
        // verify the required parameter 'feature_flag_body' is set
        if ($feature_flag_body === null || (is_array($feature_flag_body) && count($feature_flag_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_body when calling postFeatureFlag'
            );
        }

        $resourcePath = '/flags/{projectKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($clone !== null) {
            $queryParams['clone'] = ObjectSerializer::toQueryValue($clone);
        }

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($feature_flag_body)) {
            $_tempBody = $feature_flag_body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postFlagConfigScheduledChanges
     *
     * Creates a new scheduled change for a feature flag.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  \LaunchDarklyApi\Model\FlagConfigScheduledChangesPostBody $flag_config_scheduled_changes_post_body Create scheduled changes on a feature flag. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\FeatureFlagScheduledChange
     */
    public function postFlagConfigScheduledChanges($project_key, $flag_config_scheduled_changes_post_body, $feature_flag_key, $environment_key)
    {
        list($response) = $this->postFlagConfigScheduledChangesWithHttpInfo($project_key, $flag_config_scheduled_changes_post_body, $feature_flag_key, $environment_key);
        return $response;
    }

    /**
     * Operation postFlagConfigScheduledChangesWithHttpInfo
     *
     * Creates a new scheduled change for a feature flag.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  \LaunchDarklyApi\Model\FlagConfigScheduledChangesPostBody $flag_config_scheduled_changes_post_body Create scheduled changes on a feature flag. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\FeatureFlagScheduledChange, HTTP status code, HTTP response headers (array of strings)
     */
    public function postFlagConfigScheduledChangesWithHttpInfo($project_key, $flag_config_scheduled_changes_post_body, $feature_flag_key, $environment_key)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlagScheduledChange';
        $request = $this->postFlagConfigScheduledChangesRequest($project_key, $flag_config_scheduled_changes_post_body, $feature_flag_key, $environment_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\FeatureFlagScheduledChange',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postFlagConfigScheduledChangesAsync
     *
     * Creates a new scheduled change for a feature flag.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  \LaunchDarklyApi\Model\FlagConfigScheduledChangesPostBody $flag_config_scheduled_changes_post_body Create scheduled changes on a feature flag. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postFlagConfigScheduledChangesAsync($project_key, $flag_config_scheduled_changes_post_body, $feature_flag_key, $environment_key)
    {
        return $this->postFlagConfigScheduledChangesAsyncWithHttpInfo($project_key, $flag_config_scheduled_changes_post_body, $feature_flag_key, $environment_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postFlagConfigScheduledChangesAsyncWithHttpInfo
     *
     * Creates a new scheduled change for a feature flag.
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  \LaunchDarklyApi\Model\FlagConfigScheduledChangesPostBody $flag_config_scheduled_changes_post_body Create scheduled changes on a feature flag. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postFlagConfigScheduledChangesAsyncWithHttpInfo($project_key, $flag_config_scheduled_changes_post_body, $feature_flag_key, $environment_key)
    {
        $returnType = '\LaunchDarklyApi\Model\FeatureFlagScheduledChange';
        $request = $this->postFlagConfigScheduledChangesRequest($project_key, $flag_config_scheduled_changes_post_body, $feature_flag_key, $environment_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postFlagConfigScheduledChanges'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  \LaunchDarklyApi\Model\FlagConfigScheduledChangesPostBody $flag_config_scheduled_changes_post_body Create scheduled changes on a feature flag. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postFlagConfigScheduledChangesRequest($project_key, $flag_config_scheduled_changes_post_body, $feature_flag_key, $environment_key)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling postFlagConfigScheduledChanges'
            );
        }
        // verify the required parameter 'flag_config_scheduled_changes_post_body' is set
        if ($flag_config_scheduled_changes_post_body === null || (is_array($flag_config_scheduled_changes_post_body) && count($flag_config_scheduled_changes_post_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flag_config_scheduled_changes_post_body when calling postFlagConfigScheduledChanges'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling postFlagConfigScheduledChanges'
            );
        }
        // verify the required parameter 'environment_key' is set
        if ($environment_key === null || (is_array($environment_key) && count($environment_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_key when calling postFlagConfigScheduledChanges'
            );
        }

        $resourcePath = '/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }
        // path params
        if ($environment_key !== null) {
            $resourcePath = str_replace(
                '{' . 'environmentKey' . '}',
                ObjectSerializer::toPathValue($environment_key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($flag_config_scheduled_changes_post_body)) {
            $_tempBody = $flag_config_scheduled_changes_post_body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postReviewApprovalRequest
     *
     * Review approval request for a feature flag config
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $approval_request_id The approval request ID (required)
     * @param  \LaunchDarklyApi\Model\ApprovalRequestReviewConfigBody $approval_request_review_config_body Review an approval request (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LaunchDarklyApi\Model\ApprovalRequests
     */
    public function postReviewApprovalRequest($project_key, $feature_flag_key, $environment_key, $approval_request_id, $approval_request_review_config_body)
    {
        list($response) = $this->postReviewApprovalRequestWithHttpInfo($project_key, $feature_flag_key, $environment_key, $approval_request_id, $approval_request_review_config_body);
        return $response;
    }

    /**
     * Operation postReviewApprovalRequestWithHttpInfo
     *
     * Review approval request for a feature flag config
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $approval_request_id The approval request ID (required)
     * @param  \LaunchDarklyApi\Model\ApprovalRequestReviewConfigBody $approval_request_review_config_body Review an approval request (required)
     *
     * @throws \LaunchDarklyApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LaunchDarklyApi\Model\ApprovalRequests, HTTP status code, HTTP response headers (array of strings)
     */
    public function postReviewApprovalRequestWithHttpInfo($project_key, $feature_flag_key, $environment_key, $approval_request_id, $approval_request_review_config_body)
    {
        $returnType = '\LaunchDarklyApi\Model\ApprovalRequests';
        $request = $this->postReviewApprovalRequestRequest($project_key, $feature_flag_key, $environment_key, $approval_request_id, $approval_request_review_config_body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LaunchDarklyApi\Model\ApprovalRequests',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postReviewApprovalRequestAsync
     *
     * Review approval request for a feature flag config
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $approval_request_id The approval request ID (required)
     * @param  \LaunchDarklyApi\Model\ApprovalRequestReviewConfigBody $approval_request_review_config_body Review an approval request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postReviewApprovalRequestAsync($project_key, $feature_flag_key, $environment_key, $approval_request_id, $approval_request_review_config_body)
    {
        return $this->postReviewApprovalRequestAsyncWithHttpInfo($project_key, $feature_flag_key, $environment_key, $approval_request_id, $approval_request_review_config_body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postReviewApprovalRequestAsyncWithHttpInfo
     *
     * Review approval request for a feature flag config
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $approval_request_id The approval request ID (required)
     * @param  \LaunchDarklyApi\Model\ApprovalRequestReviewConfigBody $approval_request_review_config_body Review an approval request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postReviewApprovalRequestAsyncWithHttpInfo($project_key, $feature_flag_key, $environment_key, $approval_request_id, $approval_request_review_config_body)
    {
        $returnType = '\LaunchDarklyApi\Model\ApprovalRequests';
        $request = $this->postReviewApprovalRequestRequest($project_key, $feature_flag_key, $environment_key, $approval_request_id, $approval_request_review_config_body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postReviewApprovalRequest'
     *
     * @param  string $project_key The project key, used to tie the flags together under one project so they can be managed together. (required)
     * @param  string $feature_flag_key The feature flag&#39;s key. The key identifies the flag in your code. (required)
     * @param  string $environment_key The environment key, used to tie together flag configuration and users under one environment so they can be managed together. (required)
     * @param  string $approval_request_id The approval request ID (required)
     * @param  \LaunchDarklyApi\Model\ApprovalRequestReviewConfigBody $approval_request_review_config_body Review an approval request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postReviewApprovalRequestRequest($project_key, $feature_flag_key, $environment_key, $approval_request_id, $approval_request_review_config_body)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null || (is_array($project_key) && count($project_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_key when calling postReviewApprovalRequest'
            );
        }
        // verify the required parameter 'feature_flag_key' is set
        if ($feature_flag_key === null || (is_array($feature_flag_key) && count($feature_flag_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_flag_key when calling postReviewApprovalRequest'
            );
        }
        // verify the required parameter 'environment_key' is set
        if ($environment_key === null || (is_array($environment_key) && count($environment_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_key when calling postReviewApprovalRequest'
            );
        }
        // verify the required parameter 'approval_request_id' is set
        if ($approval_request_id === null || (is_array($approval_request_id) && count($approval_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $approval_request_id when calling postReviewApprovalRequest'
            );
        }
        // verify the required parameter 'approval_request_review_config_body' is set
        if ($approval_request_review_config_body === null || (is_array($approval_request_review_config_body) && count($approval_request_review_config_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $approval_request_review_config_body when calling postReviewApprovalRequest'
            );
        }

        $resourcePath = '/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/approval-requests/{approvalRequestId}/review';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                '{' . 'projectKey' . '}',
                ObjectSerializer::toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($feature_flag_key !== null) {
            $resourcePath = str_replace(
                '{' . 'featureFlagKey' . '}',
                ObjectSerializer::toPathValue($feature_flag_key),
                $resourcePath
            );
        }
        // path params
        if ($environment_key !== null) {
            $resourcePath = str_replace(
                '{' . 'environmentKey' . '}',
                ObjectSerializer::toPathValue($environment_key),
                $resourcePath
            );
        }
        // path params
        if ($approval_request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'approvalRequestId' . '}',
                ObjectSerializer::toPathValue($approval_request_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($approval_request_review_config_body)) {
            $_tempBody = $approval_request_review_config_body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
